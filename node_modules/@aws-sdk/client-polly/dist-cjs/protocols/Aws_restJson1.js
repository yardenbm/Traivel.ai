"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.de_SynthesizeSpeechCommand = exports.de_StartSpeechSynthesisTaskCommand = exports.de_PutLexiconCommand = exports.de_ListSpeechSynthesisTasksCommand = exports.de_ListLexiconsCommand = exports.de_GetSpeechSynthesisTaskCommand = exports.de_GetLexiconCommand = exports.de_DescribeVoicesCommand = exports.de_DeleteLexiconCommand = exports.se_SynthesizeSpeechCommand = exports.se_StartSpeechSynthesisTaskCommand = exports.se_PutLexiconCommand = exports.se_ListSpeechSynthesisTasksCommand = exports.se_ListLexiconsCommand = exports.se_GetSpeechSynthesisTaskCommand = exports.se_GetLexiconCommand = exports.se_DescribeVoicesCommand = exports.se_DeleteLexiconCommand = void 0;
const smithy_client_1 = require("@aws-sdk/smithy-client");
const protocol_http_1 = require("@smithy/protocol-http");
const models_0_1 = require("../models/models_0");
const PollyServiceException_1 = require("../models/PollyServiceException");
const se_DeleteLexiconCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/lexicons/{Name}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteLexiconCommand = se_DeleteLexiconCommand;
const se_DescribeVoicesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/voices";
    const query = (0, smithy_client_1.map)({
        Engine: [, input.Engine],
        LanguageCode: [, input.LanguageCode],
        IncludeAdditionalLanguageCodes: [
            () => input.IncludeAdditionalLanguageCodes !== void 0,
            () => input.IncludeAdditionalLanguageCodes.toString(),
        ],
        NextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DescribeVoicesCommand = se_DescribeVoicesCommand;
const se_GetLexiconCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/lexicons/{Name}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetLexiconCommand = se_GetLexiconCommand;
const se_GetSpeechSynthesisTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/synthesisTasks/{TaskId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "TaskId", () => input.TaskId, "{TaskId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetSpeechSynthesisTaskCommand = se_GetSpeechSynthesisTaskCommand;
const se_ListLexiconsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/lexicons";
    const query = (0, smithy_client_1.map)({
        NextToken: [, input.NextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListLexiconsCommand = se_ListLexiconsCommand;
const se_ListSpeechSynthesisTasksCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/synthesisTasks";
    const query = (0, smithy_client_1.map)({
        MaxResults: [() => input.MaxResults !== void 0, () => input.MaxResults.toString()],
        NextToken: [, input.NextToken],
        Status: [, input.Status],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListSpeechSynthesisTasksCommand = se_ListSpeechSynthesisTasksCommand;
const se_PutLexiconCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/lexicons/{Name}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "Name", () => input.Name, "{Name}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        Content: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_PutLexiconCommand = se_PutLexiconCommand;
const se_StartSpeechSynthesisTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/synthesisTasks";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        Engine: [],
        LanguageCode: [],
        LexiconNames: (_) => (0, smithy_client_1._json)(_),
        OutputFormat: [],
        OutputS3BucketName: [],
        OutputS3KeyPrefix: [],
        SampleRate: [],
        SnsTopicArn: [],
        SpeechMarkTypes: (_) => (0, smithy_client_1._json)(_),
        Text: [],
        TextType: [],
        VoiceId: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_StartSpeechSynthesisTaskCommand = se_StartSpeechSynthesisTaskCommand;
const se_SynthesizeSpeechCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v1/speech";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        Engine: [],
        LanguageCode: [],
        LexiconNames: (_) => (0, smithy_client_1._json)(_),
        OutputFormat: [],
        SampleRate: [],
        SpeechMarkTypes: (_) => (0, smithy_client_1._json)(_),
        Text: [],
        TextType: [],
        VoiceId: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_SynthesizeSpeechCommand = se_SynthesizeSpeechCommand;
const de_DeleteLexiconCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteLexiconCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.de_DeleteLexiconCommand = de_DeleteLexiconCommand;
const de_DeleteLexiconCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LexiconNotFoundException":
        case "com.amazonaws.polly#LexiconNotFoundException":
            throw await de_LexiconNotFoundExceptionRes(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.polly#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeVoicesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeVoicesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        NextToken: smithy_client_1.expectString,
        Voices: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeVoicesCommand = de_DescribeVoicesCommand;
const de_DescribeVoicesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextTokenException":
        case "com.amazonaws.polly#InvalidNextTokenException":
            throw await de_InvalidNextTokenExceptionRes(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.polly#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetLexiconCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetLexiconCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Lexicon: smithy_client_1._json,
        LexiconAttributes: (_) => de_LexiconAttributes(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetLexiconCommand = de_GetLexiconCommand;
const de_GetLexiconCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LexiconNotFoundException":
        case "com.amazonaws.polly#LexiconNotFoundException":
            throw await de_LexiconNotFoundExceptionRes(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.polly#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetSpeechSynthesisTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetSpeechSynthesisTaskCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        SynthesisTask: (_) => de_SynthesisTask(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetSpeechSynthesisTaskCommand = de_GetSpeechSynthesisTaskCommand;
const de_GetSpeechSynthesisTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidTaskIdException":
        case "com.amazonaws.polly#InvalidTaskIdException":
            throw await de_InvalidTaskIdExceptionRes(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.polly#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "SynthesisTaskNotFoundException":
        case "com.amazonaws.polly#SynthesisTaskNotFoundException":
            throw await de_SynthesisTaskNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListLexiconsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListLexiconsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Lexicons: (_) => de_LexiconDescriptionList(_, context),
        NextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListLexiconsCommand = de_ListLexiconsCommand;
const de_ListLexiconsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextTokenException":
        case "com.amazonaws.polly#InvalidNextTokenException":
            throw await de_InvalidNextTokenExceptionRes(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.polly#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListSpeechSynthesisTasksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListSpeechSynthesisTasksCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        NextToken: smithy_client_1.expectString,
        SynthesisTasks: (_) => de_SynthesisTasks(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListSpeechSynthesisTasksCommand = de_ListSpeechSynthesisTasksCommand;
const de_ListSpeechSynthesisTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextTokenException":
        case "com.amazonaws.polly#InvalidNextTokenException":
            throw await de_InvalidNextTokenExceptionRes(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.polly#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_PutLexiconCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutLexiconCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.de_PutLexiconCommand = de_PutLexiconCommand;
const de_PutLexiconCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidLexiconException":
        case "com.amazonaws.polly#InvalidLexiconException":
            throw await de_InvalidLexiconExceptionRes(parsedOutput, context);
        case "LexiconSizeExceededException":
        case "com.amazonaws.polly#LexiconSizeExceededException":
            throw await de_LexiconSizeExceededExceptionRes(parsedOutput, context);
        case "MaxLexemeLengthExceededException":
        case "com.amazonaws.polly#MaxLexemeLengthExceededException":
            throw await de_MaxLexemeLengthExceededExceptionRes(parsedOutput, context);
        case "MaxLexiconsNumberExceededException":
        case "com.amazonaws.polly#MaxLexiconsNumberExceededException":
            throw await de_MaxLexiconsNumberExceededExceptionRes(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.polly#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnsupportedPlsAlphabetException":
        case "com.amazonaws.polly#UnsupportedPlsAlphabetException":
            throw await de_UnsupportedPlsAlphabetExceptionRes(parsedOutput, context);
        case "UnsupportedPlsLanguageException":
        case "com.amazonaws.polly#UnsupportedPlsLanguageException":
            throw await de_UnsupportedPlsLanguageExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_StartSpeechSynthesisTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_StartSpeechSynthesisTaskCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        SynthesisTask: (_) => de_SynthesisTask(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_StartSpeechSynthesisTaskCommand = de_StartSpeechSynthesisTaskCommand;
const de_StartSpeechSynthesisTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EngineNotSupportedException":
        case "com.amazonaws.polly#EngineNotSupportedException":
            throw await de_EngineNotSupportedExceptionRes(parsedOutput, context);
        case "InvalidS3BucketException":
        case "com.amazonaws.polly#InvalidS3BucketException":
            throw await de_InvalidS3BucketExceptionRes(parsedOutput, context);
        case "InvalidS3KeyException":
        case "com.amazonaws.polly#InvalidS3KeyException":
            throw await de_InvalidS3KeyExceptionRes(parsedOutput, context);
        case "InvalidSampleRateException":
        case "com.amazonaws.polly#InvalidSampleRateException":
            throw await de_InvalidSampleRateExceptionRes(parsedOutput, context);
        case "InvalidSnsTopicArnException":
        case "com.amazonaws.polly#InvalidSnsTopicArnException":
            throw await de_InvalidSnsTopicArnExceptionRes(parsedOutput, context);
        case "InvalidSsmlException":
        case "com.amazonaws.polly#InvalidSsmlException":
            throw await de_InvalidSsmlExceptionRes(parsedOutput, context);
        case "LanguageNotSupportedException":
        case "com.amazonaws.polly#LanguageNotSupportedException":
            throw await de_LanguageNotSupportedExceptionRes(parsedOutput, context);
        case "LexiconNotFoundException":
        case "com.amazonaws.polly#LexiconNotFoundException":
            throw await de_LexiconNotFoundExceptionRes(parsedOutput, context);
        case "MarksNotSupportedForFormatException":
        case "com.amazonaws.polly#MarksNotSupportedForFormatException":
            throw await de_MarksNotSupportedForFormatExceptionRes(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.polly#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "SsmlMarksNotSupportedForTextTypeException":
        case "com.amazonaws.polly#SsmlMarksNotSupportedForTextTypeException":
            throw await de_SsmlMarksNotSupportedForTextTypeExceptionRes(parsedOutput, context);
        case "TextLengthExceededException":
        case "com.amazonaws.polly#TextLengthExceededException":
            throw await de_TextLengthExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_SynthesizeSpeechCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_SynthesizeSpeechCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        ContentType: [, output.headers["content-type"]],
        RequestCharacters: [
            () => void 0 !== output.headers["x-amzn-requestcharacters"],
            () => (0, smithy_client_1.strictParseInt32)(output.headers["x-amzn-requestcharacters"]),
        ],
    });
    const data = output.body;
    context.sdkStreamMixin(data);
    contents.AudioStream = data;
    return contents;
};
exports.de_SynthesizeSpeechCommand = de_SynthesizeSpeechCommand;
const de_SynthesizeSpeechCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EngineNotSupportedException":
        case "com.amazonaws.polly#EngineNotSupportedException":
            throw await de_EngineNotSupportedExceptionRes(parsedOutput, context);
        case "InvalidSampleRateException":
        case "com.amazonaws.polly#InvalidSampleRateException":
            throw await de_InvalidSampleRateExceptionRes(parsedOutput, context);
        case "InvalidSsmlException":
        case "com.amazonaws.polly#InvalidSsmlException":
            throw await de_InvalidSsmlExceptionRes(parsedOutput, context);
        case "LanguageNotSupportedException":
        case "com.amazonaws.polly#LanguageNotSupportedException":
            throw await de_LanguageNotSupportedExceptionRes(parsedOutput, context);
        case "LexiconNotFoundException":
        case "com.amazonaws.polly#LexiconNotFoundException":
            throw await de_LexiconNotFoundExceptionRes(parsedOutput, context);
        case "MarksNotSupportedForFormatException":
        case "com.amazonaws.polly#MarksNotSupportedForFormatException":
            throw await de_MarksNotSupportedForFormatExceptionRes(parsedOutput, context);
        case "ServiceFailureException":
        case "com.amazonaws.polly#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "SsmlMarksNotSupportedForTextTypeException":
        case "com.amazonaws.polly#SsmlMarksNotSupportedForTextTypeException":
            throw await de_SsmlMarksNotSupportedForTextTypeExceptionRes(parsedOutput, context);
        case "TextLengthExceededException":
        case "com.amazonaws.polly#TextLengthExceededException":
            throw await de_TextLengthExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = (0, smithy_client_1.withBaseException)(PollyServiceException_1.PollyServiceException);
const de_EngineNotSupportedExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.EngineNotSupportedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidLexiconExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidLexiconException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidNextTokenExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidNextTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidS3BucketExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidS3BucketException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidS3KeyExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidS3KeyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidSampleRateExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidSampleRateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidSnsTopicArnExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidSnsTopicArnException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidSsmlExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidSsmlException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidTaskIdExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidTaskIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_LanguageNotSupportedExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.LanguageNotSupportedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_LexiconNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.LexiconNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_LexiconSizeExceededExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.LexiconSizeExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_MarksNotSupportedForFormatExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.MarksNotSupportedForFormatException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_MaxLexemeLengthExceededExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.MaxLexemeLengthExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_MaxLexiconsNumberExceededExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.MaxLexiconsNumberExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ServiceFailureExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ServiceFailureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_SsmlMarksNotSupportedForTextTypeExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.SsmlMarksNotSupportedForTextTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_SynthesisTaskNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.SynthesisTaskNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_TextLengthExceededExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.TextLengthExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_UnsupportedPlsAlphabetExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.UnsupportedPlsAlphabetException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_UnsupportedPlsLanguageExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.UnsupportedPlsLanguageException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_LexiconAttributes = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Alphabet: smithy_client_1.expectString,
        LanguageCode: smithy_client_1.expectString,
        LastModified: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        LexemesCount: smithy_client_1.expectInt32,
        LexiconArn: smithy_client_1.expectString,
        Size: smithy_client_1.expectInt32,
    });
};
const de_LexiconDescription = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Attributes: (_) => de_LexiconAttributes(_, context),
        Name: smithy_client_1.expectString,
    });
};
const de_LexiconDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LexiconDescription(entry, context);
    });
    return retVal;
};
const de_SynthesisTask = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        CreationTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        Engine: smithy_client_1.expectString,
        LanguageCode: smithy_client_1.expectString,
        LexiconNames: smithy_client_1._json,
        OutputFormat: smithy_client_1.expectString,
        OutputUri: smithy_client_1.expectString,
        RequestCharacters: smithy_client_1.expectInt32,
        SampleRate: smithy_client_1.expectString,
        SnsTopicArn: smithy_client_1.expectString,
        SpeechMarkTypes: smithy_client_1._json,
        TaskId: smithy_client_1.expectString,
        TaskStatus: smithy_client_1.expectString,
        TaskStatusReason: smithy_client_1.expectString,
        TextType: smithy_client_1.expectString,
        VoiceId: smithy_client_1.expectString,
    });
};
const de_SynthesisTasks = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SynthesisTask(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
